"""
Some part of the following code was AI-Generated by Gemini Pro 2.5 with the following prompt:

The following file is the basic testing for our project TinyTurns and the
classes it used to represent the player playerClass.py

It is a simple PvP Turn-Based Game that utilizes TCP, pygame, and
uses pickle to send the Class data so Client can update it.

TinyTurns should run on a Server that can be accessed by 2 clients to play the game.
The server will not start the main game function if there is only 1 client that have joined.

Create a Server.py and Client.py that replicates the file attached but with TCP connection

https://g.co/gemini/share/341434c740fc
"""

import socket
import pickle
import threading
from playerClass import Player

# --- Server Configuration ---
# Use '0.0.0.0' to allow connections from any IP, or a specific IP.
HOST = '127.0.0.1'  # localhost
PORT = 65432
MAX_BUFFER_SIZE = 4096

# --- Game State ---
clients = []
players = {}
game_state = {
    "players": players,
    "turn": 1,
    "game_over": False,
    "message": "Waiting for players..."
}
game_started = False
lock = threading.Lock()

# --- Server Functions ---

def shutdown_and_reset_all():
    """
    Forcefully closes all client connections and resets the server state.
    This is the authoritative reset command.
    """
    global clients
    with lock:
        print("[SERVER] Reset triggered. Closing all client connections.")
        for conn in clients:
            try:
                conn.close()
            except Exception as e:
                print(f"[SERVER] Error closing a client connection: {e}")
        
        # After closing connections, perform the main reset
        reset_server()

def handle_client(conn, player_id):
    """
    Handles communication with a single client in a separate thread.
    """
    global game_state, game_started

    print(f"[SERVER] Player {player_id} connected.")
    # Send the player their assigned ID. This might fail if reset happens fast.
    try:
        conn.send(pickle.dumps(player_id))
    except Exception as e:
        print(f"[SERVER] Failed to send player ID to {player_id}: {e}")
        # The connection is likely already being closed by a reset.
        if conn in clients: clients.remove(conn)
        conn.close()
        return

    while True:
        try:
            data = conn.recv(MAX_BUFFER_SIZE)
            if not data:
                print(f"[SERVER] Player {player_id} disconnected gracefully.")
                break

            action = pickle.loads(data)
            print(f"[SERVER] Received action '{action}' from Player {player_id}")

            # NEW: Handle reset request, which can be received at any time.
            if action == "request_reset":
                print(f"[SERVER] Player {player_id} initiated a game reset.")
                shutdown_and_reset_all()
                # This thread's connection is now closed, so the loop will break.
                break

            # Process game actions only if the game is not over.
            with lock:
                if not game_state["game_over"]:
                    process_action(player_id, action)
                    broadcast_gamestate()

        except (ConnectionResetError, EOFError):
            print(f"[SERVER] Player {player_id} lost connection.")
            break
        except Exception as e:
            print(f"[SERVER] An error occurred with Player {player_id}: {e}")
            break

    # --- Client disconnection cleanup ---
    with lock:
        if conn in clients:
            clients.remove(conn)
            print(f"[SERVER] Player {player_id} removed from active clients.")
        
        # If a client disconnects mid-game, end the game.
        if game_started and not game_state["game_over"]:
            game_state["game_over"] = True
            game_state["message"] = f"Player {player_id} disconnected. Game over."
            broadcast_gamestate()

        # If all clients have left, ensure the server is reset for the next game.
        if not clients and game_started:
            print("[SERVER] All clients disconnected. Server is resetting.")
            reset_server()

    conn.close()


def process_action(player_id, action):
    # ... (This function remains unchanged)
    """
    Updates the game state based on the received action.
    This function assumes it's called within a lock.
    """
    # Determine attacker and defender
    current_player_turn = 1 if game_state["turn"] % 2 != 0 else 2
    if player_id != current_player_turn:
        return

    attacker = game_state["players"][player_id]
    defender_id = 2 if player_id == 1 else 1
    defender = game_state["players"][defender_id]
    attacker_name = f"Player {player_id}"
    defender_name = f"Player {defender_id}"

    action_message = ""

    if action == '0':
        action_message = f"{attacker_name} skipped their turn."
    elif action == '1':
        damage = defender.takeDMG(attacker, 50)
        action_message = f"{attacker_name} used Basic Attack! {defender_name} took {damage:,} damage."
    elif action == '2':
        if attacker.SP >= 3:
            attacker.SP -= 3
            damage = defender.takeDMG(attacker, 75)
            action_message = f"{attacker_name} used Heavy Attack! {defender_name} took {damage:,} damage."
        else:
            action_message = "Not enough SP for Heavy Attack! Turn skipped."
    elif action == '3':
        if attacker.SP >= 6:
            attacker.SP -= 6
            defender.debuff()
            action_message = f"{attacker_name} debuffed {defender_name}!"
        else:
            action_message = "Not enough SP for Debuff! Turn skipped."
    elif action == '4':
        if attacker.SP >= 6:
            attacker.SP -= 6
            attacker.CRITBuff()
            action_message = f"{attacker_name} used CRIT Buff!"
        else:
            action_message = "Not enough SP for CRIT Buff! Turn skipped."
    elif action == '5':
        if attacker.SP >= 6:
            attacker.SP -= 6
            attacker.enchancement()
            action_message = f"{attacker_name} used Enhancement!"
        else:
            action_message = "Not enough SP for Enhancement! Turn skipped."
    
    game_state["message"] = action_message
    attacker.turnEnd()

    if defender.currHP <= 0:
        game_state["game_over"] = True
        game_state["message"] = f"{action_message}\n*** {attacker_name} wins! ***"
    elif attacker.currHP <= 0:
        game_state["game_over"] = True
        game_state["message"] = f"{action_message}\n*** {defender_name} wins! ***"
    else:
        game_state["turn"] += 1


def broadcast_gamestate():
    """ Sends the current game state to all connected clients. """
    pickled_state = pickle.dumps(game_state)
    for client_conn in list(clients): # Use a copy in case the list changes
        try:
            client_conn.sendall(pickled_state)
        except Exception as e:
            print(f"[SERVER] Failed to send state to a client (might be disconnecting): {e}")


def reset_server():
    """Resets the game state for a new game."""
    global game_state, game_started, players, clients
    print("[SERVER] Resetting game state.")
    players = {}
    clients = [] # This is the crucial part for reconnection
    game_state = {
        "players": players,
        "turn": 1,
        "game_over": False,
        "message": "Waiting for players..."
    }
    game_started = False


def main():
    # ... (This function remains largely unchanged)
    global game_started
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind((HOST, PORT))
    server_socket.listen(2)
    print(f"[SERVER] Listening on {HOST}:{PORT}")

    while True:
        conn, addr = server_socket.accept()
        with lock:
            if len(clients) < 2:
                clients.append(conn)
                player_id = len(clients)
                thread = threading.Thread(target=handle_client, args=(conn, player_id))
                thread.daemon = True
                thread.start()
                
                if len(clients) == 2 and not game_started:
                    game_started = True
                    players[1] = Player()
                    players[2] = Player()
                    game_state["message"] = "Game Start! Player 1's Turn."
                    print("[SERVER] Two players connected. Starting the game!")
                    broadcast_gamestate()
            else:
                print(f"[SERVER] Denied connection from {addr}. Server is full or resetting.")
                try:
                    full_message = {"game_over": True, "message": "Server is full. Please try again later."}
                    conn.send(pickle.dumps(full_message))
                finally:
                    conn.close()

if __name__ == "__main__":
    main()