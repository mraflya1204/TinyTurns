"""
The following is AI-Generated by Gemini Pro 2.5 with the following prompt:

The following file is the basic testing for our project TinyTurns and the
classes it used to represent the player playerClass.py

It is a simple PvP Turn-Based Game that utilizes TCP, pygame, and
uses pickle to send the Class data so Client can update it.

TinyTurns should run on a Server that can be accessed by 2 clients to play the game.
The server will not start the main game function if there is only 1 client that have joined.

Create a Server.py and Client.py that replicates the file attached but with TCP connection

https://g.co/gemini/share/341434c740fc
"""

import socket
import pickle
import threading
from playerClass import Player

# --- Server Configuration ---
# Use '0.0.0.0' to allow connections from any IP, or a specific IP.
HOST = '127.0.0.1'  # localhost
PORT = 65432
MAX_BUFFER_SIZE = 4096

# --- Game State ---
clients = []
players = {}
game_state = {
    "players": players,
    "turn": 1,
    "game_over": False,
    "message": "Waiting for players..."
}
game_started = False
lock = threading.Lock()


# --- Server Functions ---
def handle_client(conn, player_id):
    """
    Handles communication with a single client in a separate thread.
    """
    global game_state, game_started

    print(f"[SERVER] Player {player_id} connected.")

    # Send the player their assigned ID
    conn.send(pickle.dumps(player_id))

    while True:
        try:
            # Wait to receive an action from the client
            data = conn.recv(MAX_BUFFER_SIZE)
            if not data:
                print(f"[SERVER] Player {player_id} disconnected.")
                break

            action = pickle.loads(data)
            print(f"[SERVER] Received action '{action}' from Player {player_id}")

            # Process the action using a lock to prevent race conditions
            with lock:
                process_action(player_id, action)

                # After processing, broadcast the new state to all clients
                broadcast_gamestate()

                # Check for game over condition
                if game_state["game_over"]:
                    print("[SERVER] Game over. Closing connections.")
                    break

        except (ConnectionResetError, EOFError):
            print(f"[SERVER] Player {player_id} lost connection.")
            # Handle disconnection during game
            with lock:
                game_state["game_over"] = True
                game_state["message"] = f"Player {player_id} disconnected. Game over."
                broadcast_gamestate()
            break
        except Exception as e:
            print(f"[SERVER] An error occurred with Player {player_id}: {e}")
            break

    conn.close()
    # Basic cleanup
    if conn in clients:
        clients.remove(conn)
    if not clients:
        print("[SERVER] All clients disconnected. Server is resetting.")
        reset_server()


def process_action(player_id, action):
    """
    Updates the game state based on the received action.
    This function assumes it's called within a lock.
    """
    # Determine attacker and defender
    current_player_turn = 1 if game_state["turn"] % 2 != 0 else 2
    if player_id != current_player_turn:
        # It's not this player's turn. This should ideally not happen.
        return

    attacker = game_state["players"][player_id]
    defender_id = 2 if player_id == 1 else 1
    defender = game_state["players"][defender_id]
    attacker_name = f"Player {player_id}"
    defender_name = f"Player {defender_id}"

    action_message = ""

    # Execute action
    if action == '0':
        action_message = f"{attacker_name} skipped their turn."
    elif action == '1':  # Basic Attack
        damage = defender.takeDMG(attacker, 50)
        action_message = f"{attacker_name} used Basic Attack! {defender_name} took {damage:,} damage."
    elif action == '2':  # Heavy Attack
        if attacker.SP >= 3:
            attacker.SP -= 3
            damage = defender.takeDMG(attacker, 75)
            action_message = f"{attacker_name} used Heavy Attack! {defender_name} took {damage:,} damage."
        else:
            action_message = "Not enough SP for Heavy Attack! Turn skipped."
    elif action == '3':  # Debuff
        if attacker.SP >= 6:
            attacker.SP -= 6
            defender.debuff()
            action_message = f"{attacker_name} debuffed {defender_name}!"
        else:
            action_message = "Not enough SP for Debuff! Turn skipped."
    elif action == '4':  # CRIT Buff
        if attacker.SP >= 6:
            attacker.SP -= 6
            attacker.CRITBuff()
            action_message = f"{attacker_name} used CRIT Buff!"
        else:
            action_message = "Not enough SP for CRIT Buff! Turn skipped."
    elif action == '5':  # Enhancement
        if attacker.SP >= 6:
            attacker.SP -= 6
            attacker.enchancement()
            action_message = f"{attacker_name} used Enhancement!"
        else:
            action_message = "Not enough SP for Enhancement! Turn skipped."

    game_state["message"] = action_message

    # End of turn actions
    attacker.turnEnd()

    # Check for game over
    if defender.currHP <= 0:
        game_state["game_over"] = True
        game_state["message"] = f"{action_message}\n*** {attacker_name} wins! ***"
    elif attacker.currHP <= 0:  # Should not happen, but for safety
        game_state["game_over"] = True
        game_state["message"] = f"{action_message}\n*** {defender_name} wins! ***"
    else:
        # Move to the next turn
        game_state["turn"] += 1


def broadcast_gamestate():
    """
    Sends the current game state to all connected clients.
    """
    pickled_state = pickle.dumps(game_state)
    for client_conn in clients:
        try:
            client_conn.sendall(pickled_state)
        except Exception as e:
            print(f"[SERVER] Failed to send state to a client: {e}")


def reset_server():
    """Resets the game state for a new game."""
    global game_state, game_started, players, clients
    players = {}
    clients = []
    game_state = {
        "players": players,
        "turn": 1,
        "game_over": False,
        "message": "Waiting for players..."
    }
    game_started = False
    print("[SERVER] Server has been reset.")


def main():
    """Main function to run the server."""
    global game_started
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # This allows reusing the address, helpful for quick restarts
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind((HOST, PORT))
    server_socket.listen(2)
    print(f"[SERVER] Listening on {HOST}:{PORT}")

    while True:
        # Accept new connections
        conn, addr = server_socket.accept()

        with lock:
            if len(clients) < 2:
                clients.append(conn)
                player_id = len(clients)  # Assign Player 1 or Player 2

                thread = threading.Thread(target=handle_client, args=(conn, player_id))
                thread.daemon = True  # Allows main thread to exit even if threads are running
                thread.start()

                if len(clients) == 2 and not game_started:
                    game_started = True
                    # Initialize players
                    players[1] = Player()
                    players[2] = Player()
                    game_state["message"] = "Game Start! Player 1's Turn."
                    print("[SERVER] Two players connected. Starting the game!")
                    broadcast_gamestate()
            else:
                print(f"[SERVER] Denied connection from {addr}. Server is full.")
                # Inform the connecting client that the server is full and close
                try:
                    full_message = {"game_over": True, "message": "Server is full. Please try again later."}
                    conn.send(pickle.dumps(full_message))
                except Exception as e:
                    print(f"[SERVER] Could not inform full server to {addr}: {e}")
                finally:
                    conn.close()


if __name__ == "__main__":
    main()
